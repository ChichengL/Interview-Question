#### 实现模板字符串

```js
const year = '2024'
const month = '08'
const day = '19'
function render(str){
    return str.replace(/\$\{(\w+)\}/g,(match,key)=>{
        return eval(key);
    })
}
console.log(render('${year}-${month}-${day}'));
```





#### 实现并发控制

题目:

```js
class Concurrence{
	add(){}
}
const task = (ms, content) => {
    return () => new Promise((resolve) => {
        setTimeout(() => {
            console.log(content);
            resolve(content);
        }, ms);
    });
};

const c = new Concurrence();
c.add(task(1000, 1));
c.add(task(500, 2));
c.add(task(300, 3));
c.add(task(400, 4));
//期望输出2,3,1,4
```

答案：

```js
class Concurrence {
    constructor() {
        this.queue = []; // 存放待执行的任务
        this.max = 2;    // 最大并发数
        this.running = 0; // 当前正在运行的任务数
    }

    async add(task) {
        // 如果正在运行的任务数小于最大并发数，直接执行任务
        if (this.running < this.max) {
            this.runTask(task);
        } else {
            // 否则将任务推入队列等待
            await new Promise(resolve => this.queue.push(resolve));
            this.runTask(task);
        }
    }

    runTask(task) {
        this.running++;
        task().then(() => {
            this.running--;
            // 执行队列中的下一个任务
            if (this.queue.length > 0) {
                const nextTask = this.queue.shift();
                nextTask(); // 通过 resolve 来触发下一个任务
            }
        });
    }
}

const task = (ms, content) => {
    return () => new Promise((resolve) => {
        setTimeout(() => {
            console.log(content);
            resolve(content);
        }, ms);
    });
};

const c = new Concurrence();
c.add(task(1000, 1));
c.add(task(500, 2));
c.add(task(300, 3));
c.add(task(400, 4));
```





#### 手写洋葱模型



#### [最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/description/)



